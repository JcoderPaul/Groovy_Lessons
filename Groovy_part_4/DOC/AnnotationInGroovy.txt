****** Метапрограммирование во время компиляции ******

Используя определенные аннотации, мы можем легко изменить структуру класса
во время компиляции. Другими словами, мы можем использовать аннотации для
модификации абстрактного синтаксического дерева класса при компиляции.

Давайте обсудим некоторые аннотации, которые очень удобны в Groovy для
сокращения шаблонного кода. Многие из них доступны в пакете groovy.transform.

Если мы внимательно проанализируем, мы поймем, что несколько аннотаций
предоставляют функции, аналогичные Java Project Lombok.

*** @ToString ***

Аннотация @ToString добавляет реализацию метода toString по умолчанию в класс
во время компиляции. Все, что нам нужно, это добавить аннотацию к классу.

Например, давайте добавим аннотацию @ToString к нашему классу Employee :

********************************************************************************************
@ToString
class Employee {
    long id
    String firstName
    String lastName
    int age
}
********************************************************************************************

Теперь мы создадим объект класса Employee и проверим строку, возвращаемую методом toString:

********************************************************************************************
Employee employee = new Employee()
employee.id = 1
employee.firstName = "norman"
employee.lastName = "lewis"
employee.age = 28
********************************************************************************************
assert employee.toString() == "com.foreach.metaprogramming.Employee(1, norman, lewis, 28)"
********************************************************************************************

Мы также можем объявить такие параметры, как excludes, include, includePackage и ignoreNulls
с помощью @ToString для изменения выходной строки.

Например, исключим id и package из строки объекта Employee:
********************************************************************************************
@ToString(includePackage=false, excludes=['id'])
********************************************************************************************
assert employee.toString() == "Employee(norman, lewis, 28)"
********************************************************************************************

*** @TupleConstructor ***

@TupleConstructor в Groovy используется, чтобы добавить в класс параметризованный конструктор.
Эта аннотация создает конструктор с параметром для каждого свойства.

Например, добавим @TupleConstructor в класс Employee :

********************************************************************************************
@TupleConstructor
class Employee {
    long id
    String firstName
    String lastName
    int age
}
********************************************************************************************

Теперь мы можем создать параметры передачи объекта Employee в порядке свойств, определенных в классе.

********************************************************************************************
Employee norman = new Employee(1, "norman", "lewis", 28)
********************************************************************************************
assert norman.toString() == "Employee(norman, lewis, 28)"
********************************************************************************************
Если мы не укажем значения свойств при создании объектов, Groovy будет учитывать значения по умолчанию:

********************************************************************************************
Employee snape = new Employee(2, "snape")
********************************************************************************************
assert snape.toString() == "Employee(snape, null, 0)"
********************************************************************************************

Подобно @ToString, мы можем объявить такие параметры, как excludes, include и includeSuperProperties
с помощью @TupleConstructor, чтобы при необходимости изменить поведение связанного с ним конструктора.

*** @EqualsAndHashCode ***

Мы можем использовать @EqualsAndHashCode для создания стандартной реализации методов equals и
hashCode во время компиляции.

Если добавить @EqualsAndHashCode, в класс Employee, то поведение его будет следующим:

********************************************************************************************
Employee normanCopy = new Employee(1, "norman", "lewis", 28)
********************************************************************************************
assert norman == normanCopy
assert norman.hashCode() == normanCopy.hashCode()
********************************************************************************************

*** @Canonical ***

@Canonical представляет собой комбинацию аннотаций @ToString, @TupleConstructor и @EqualsAndHashCode .

Просто добавив ее, мы можем легко включить все три в класс Groovy. Кроме того, мы можем объявить
@Canonical с любым из конкретных параметров всех трех аннотаций.

*** @AutoClone ***

Быстрый и надежный способ реализовать интерфейс Cloneable — добавить аннотацию @AutoClone.

Если добавить @AutoClone в класс Employee, будет легитимным код ниже:

********************************************************************************************
try {
    Employee norman = new Employee(1, "norman", "lewis", 28)
    def normanCopy = norman.clone()
    assert norman == normanCopy
} catch (CloneNotSupportedException e) {
    e.printStackTrace()
}
********************************************************************************************

*** @Log ***

Чтобы добавить поддержку ведения журнала в любой класс Groovy, все, что нам нужно, это добавить
аннотации, доступные в пакете groovy.util.logging.

Если добавить аннотацию @Log к классу Employee, то, после этого используя метод logEmp:

********************************************************************************************
def logEmp() {
    log.info "Employee: $lastName, $firstName is of $age years age"
}
********************************************************************************************

Вызов метода logEmp для объекта Employee покажет журналы на консоли:

********************************************************************************************
Employee employee = new Employee(1, "Norman", "Lewis", 28)
employee.logEmp()
********************************************************************************************
INFO: Employee: Lewis, Norman is of 28 years age
********************************************************************************************